<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>RoboKin - Robot Kinematics Simulator</title>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#09090b">
<meta name="apple-mobile-web-app-capable" content="yes">
<link rel="icon" href="icon-192.svg" type="image/svg+xml">
<script src="https://cdn.tailwindcss.com"></script>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
<script>
tailwind.config = {
  theme: {
    extend: {
      fontFamily: {
        sans: ['Inter', 'sans-serif'],
        mono: ['JetBrains Mono', 'monospace']
      }
    }
  }
}
</script>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#09090b;--panel:#18181b;--input:#27272a;--border:#3f3f46;--text:#f4f4f5;
  --muted:#a1a1aa;--text-secondary:#a1a1aa;--text-muted:#71717a;
  --accent:#f59e0b;--accent2:#fbbf24;
  --j0:#ef4444;--j1:#f97316;--j2:#eab308;--j3:#22c55e;--j4:#3b82f6;--j5:#a855f7;
}
html,body{height:100%;overflow:hidden;background:var(--bg);color:var(--text);font-family:'Inter',sans-serif;font-size:14px}
#app{display:flex;height:100%}
#viewport-wrap{flex:1;position:relative;overflow:hidden}
canvas{display:block;width:100%!important;height:100%!important}
#overlay{position:absolute;top:12px;left:12px;background:rgba(0,0,0,.9);border:1px solid var(--border);border-radius:8px;padding:10px 14px;font-size:12px;line-height:1.6;pointer-events:none;backdrop-filter:blur(4px);font-family:'JetBrains Mono',monospace}
#overlay .lbl{color:var(--muted);margin-right:4px}
#overlay .val{color:var(--accent);font-family:'JetBrains Mono',monospace}
#hint{position:absolute;bottom:12px;left:50%;transform:translateX(-50%);color:var(--text-muted);font-size:11px;pointer-events:none;opacity:.7;font-family:'JetBrains Mono',monospace}

/* Sidebar */
#sidebar{width:320px;background:var(--panel);border-left:1px solid var(--border);display:flex;flex-direction:column;overflow-y:auto;overflow-x:hidden}
::-webkit-scrollbar{width:8px;height:8px}
::-webkit-scrollbar-track{background:#18181b}
::-webkit-scrollbar-thumb{background:#3f3f46;border-radius:4px}
::-webkit-scrollbar-thumb:hover{background:#52525b}
.section{padding:14px 16px;border-bottom:1px solid var(--border)}
.section h2{font-size:11px;text-transform:uppercase;letter-spacing:.08em;color:var(--text-muted);margin-bottom:10px;font-weight:600;font-family:'JetBrains Mono',monospace}
.logo{padding:16px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:10px}
.logo h1{font-size:18px;font-weight:700;color:var(--accent);font-family:'JetBrains Mono',monospace}
.logo span{font-size:11px;color:var(--muted)}

/* Mode toggle */
.mode-toggle{display:flex;background:var(--input);border-radius:8px;overflow:hidden}
.mode-btn{flex:1;padding:8px;text-align:center;cursor:pointer;font-size:12px;font-weight:600;transition:all .2s;border:none;background:transparent;color:var(--muted);font-family:'JetBrains Mono',monospace}
.mode-btn.active{background:var(--accent);color:var(--bg)}

/* Preset selector */
select{width:100%;padding:7px 10px;background:var(--input);color:var(--text);border:1px solid var(--border);border-radius:8px;font-size:13px;outline:none;font-family:'JetBrains Mono',monospace}
select:focus{border-color:var(--accent)}

/* Sliders */
.joint-row{margin-bottom:10px}
.joint-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:4px}
.joint-label{font-size:12px;font-weight:600;font-family:'JetBrains Mono',monospace}
.joint-value{font-size:11px;color:var(--accent);font-family:'JetBrains Mono',monospace}
input[type=range]{-webkit-appearance:none;width:100%;height:6px;border-radius:3px;background:var(--input);outline:none}
input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:16px;height:16px;border-radius:50%;cursor:pointer}

/* IK inputs */
.ik-row{display:flex;gap:8px;margin-bottom:8px;align-items:center}
.ik-row label{font-size:12px;color:var(--text-muted);width:20px;text-align:right;flex-shrink:0;font-family:'JetBrains Mono',monospace}
.ik-row input[type=number]{flex:1;padding:6px 8px;background:var(--input);color:var(--text);border:1px solid var(--border);border-radius:8px;font-size:12px;font-family:'JetBrains Mono',monospace;outline:none}
.ik-row input[type=number]:focus{border-color:var(--accent)}
.btn{padding:10px 16px;border:none;border-radius:8px;font-size:12px;font-weight:700;cursor:pointer;transition:colors .15s;width:100%;font-family:'JetBrains Mono',monospace}
.btn-primary{background:var(--accent);color:#18181b}
.btn-primary:hover{background:var(--accent2)}
.btn-outline{background:var(--input);border:1px solid var(--border);color:var(--muted)}
.btn-outline:hover{background:#3f3f46;color:var(--text)}
.ik-status{font-size:11px;margin-top:6px;padding:4px 8px;border-radius:4px;text-align:center}
.ik-status.ok{background:rgba(34,197,94,.15);color:#22c55e}
.ik-status.fail{background:rgba(239,68,68,.15);color:#ef4444}
.ik-status.working{background:rgba(245,158,11,.15);color:var(--accent)}

/* DH table */
.dh-table{width:100%;font-size:11px;border-collapse:collapse;font-family:'JetBrains Mono',monospace}
.dh-table th{color:var(--text-muted);font-weight:600;padding:4px 6px;text-align:right;border-bottom:1px solid var(--border)}
.dh-table td{padding:4px 6px;text-align:right;font-family:'JetBrains Mono',monospace;color:var(--text)}
.dh-table tr:hover td{background:rgba(245,158,11,.05)}

/* Toggle row */
.toggle-row{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
.toggle-row label{font-size:12px;color:var(--muted)}
.toggle{position:relative;width:36px;height:20px;cursor:pointer}
.toggle input{display:none}
.toggle .slider{position:absolute;inset:0;background:#3f3f46;border-radius:10px;transition:all .2s}
.toggle .slider::after{content:'';position:absolute;left:3px;top:3px;width:14px;height:14px;background:white;border-radius:50%;transition:all .2s}
.toggle input:checked+.slider{background:var(--accent)}
.toggle input:checked+.slider::after{left:19px;background:white}

/* Path planner */
.wp-list{max-height:340px;overflow-y:auto}
.wp-row{display:flex;gap:4px;margin-bottom:6px;align-items:center}
.wp-num{width:22px;height:22px;border-radius:50%;background:var(--input);color:var(--text-muted);font-size:10px;font-family:'JetBrains Mono',monospace;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:all .2s}
.wp-row.active .wp-num{background:var(--accent);color:var(--bg)}
.wp-row.reached .wp-num{background:rgba(34,197,94,.3);color:#22c55e}
.wp-row input[type=number]{width:100%;padding:4px 6px;background:var(--input);color:var(--text);border:1px solid var(--border);border-radius:6px;font-size:11px;font-family:'JetBrains Mono',monospace;outline:none}
.wp-row input[type=number]:focus{border-color:var(--accent)}
.wp-header{display:flex;gap:4px;margin-bottom:6px;align-items:center;padding-left:26px}
.wp-header span{flex:1;font-size:10px;color:var(--text-muted);text-align:center;font-family:'JetBrains Mono',monospace}
.path-controls{display:flex;gap:6px;margin-top:10px}
.path-controls .btn{flex:1}
.path-progress{font-size:11px;color:var(--muted);text-align:center;margin-top:8px;font-family:'JetBrains Mono',monospace}
.speed-row{display:flex;align-items:center;gap:8px;margin-top:10px}
.speed-row label{font-size:11px;color:var(--text-muted);font-family:'JetBrains Mono',monospace;flex-shrink:0}
.speed-row select{flex:1;padding:4px 6px;font-size:11px}

@media(max-width:768px){
  #app{flex-direction:column}
  #sidebar{width:100%;height:45%;border-left:none;border-top:1px solid var(--border)}
  #viewport-wrap{height:55%}
}
</style>
</head>
<body>
<div id="app">
  <div id="viewport-wrap">
    <canvas id="viewport"></canvas>
    <div id="overlay">
      <div><span class="lbl">End-Effector</span></div>
      <div><span class="lbl">X:</span><span class="val" id="ee-x">0.000</span>
           <span class="lbl" style="margin-left:8px">Y:</span><span class="val" id="ee-y">0.000</span>
           <span class="lbl" style="margin-left:8px">Z:</span><span class="val" id="ee-z">0.000</span></div>
      <div style="margin-top:4px"><span class="lbl">Reach:</span><span class="val" id="ee-r">0.000</span></div>
    </div>
    <div id="hint">Drag to orbit &middot; Scroll to zoom &middot; Right-drag to pan</div>
  </div>
  <div id="sidebar">
    <div class="logo">
      <svg width="28" height="28" viewBox="0 0 28 28" fill="none"><circle cx="14" cy="22" r="3" fill="#f59e0b"/><line x1="14" y1="22" x2="14" y2="14" stroke="#f59e0b" stroke-width="2.5" stroke-linecap="round"/><circle cx="14" cy="14" r="2.5" fill="#fbbf24"/><line x1="14" y1="14" x2="20" y2="8" stroke="#fbbf24" stroke-width="2" stroke-linecap="round"/><circle cx="20" cy="8" r="2" fill="#a855f7"/><line x1="20" y1="8" x2="18" y2="3" stroke="#a855f7" stroke-width="1.5" stroke-linecap="round"/><circle cx="18" cy="3" r="1.5" fill="#eab308"/></svg>
      <div><h1>RoboKin</h1><span>Kinematics Simulator</span></div>
    </div>

    <div class="section">
      <h2>Mode</h2>
      <div class="mode-toggle">
        <button class="mode-btn active" data-mode="fk">FK</button>
        <button class="mode-btn" data-mode="ik">IK</button>
        <button class="mode-btn" data-mode="path">Path</button>
      </div>
    </div>

    <div class="section">
      <h2>Robot Preset</h2>
      <select id="preset-select">
        <option value="kuka">KUKA KR 500</option>
        <option value="ur5">UR5-like</option>
        <option value="scara">4-DOF SCARA</option>
        <option value="3link">3-Link Planar</option>
      </select>
    </div>

    <div class="section" id="fk-section">
      <h2>Joint Angles</h2>
      <div id="fk-sliders"></div>
      <button class="btn btn-outline" id="reset-joints" style="margin-top:8px">Reset to Zero</button>
    </div>

    <div class="section" id="ik-section" style="display:none">
      <h2>Target Position</h2>
      <div class="ik-row"><label>X</label><input type="number" id="ik-x" step="0.05" value="0.5"></div>
      <div class="ik-row"><label>Y</label><input type="number" id="ik-y" step="0.05" value="0.8"></div>
      <div class="ik-row"><label>Z</label><input type="number" id="ik-z" step="0.05" value="0.3"></div>
      <button class="btn btn-primary" id="solve-ik" style="margin-top:8px">Solve IK</button>
      <div class="ik-status" id="ik-status" style="display:none"></div>
      <p style="font-size:11px;color:var(--muted);margin-top:8px">You can also drag the amber target sphere in the 3D view.</p>
    </div>

    <div class="section" id="path-section" style="display:none">
      <h2>Path Planner</h2>
      <div class="wp-header"><span>X</span><span>Y</span><span>Z</span></div>
      <div class="wp-list" id="wp-list"></div>
      <div class="speed-row">
        <label>Speed</label>
        <select id="path-speed">
          <option value="2000">Slow</option>
          <option value="800" selected>Normal</option>
          <option value="350">Fast</option>
        </select>
      </div>
      <div class="path-controls">
        <button class="btn btn-primary" id="path-play">Play</button>
        <button class="btn btn-outline" id="path-stop">Stop</button>
      </div>
      <div class="path-progress" id="path-progress"></div>
    </div>

    <div class="section">
      <h2>Display</h2>
      <div class="toggle-row"><label>Joint Frames</label><label class="toggle"><input type="checkbox" id="show-frames"><span class="slider"></span></label></div>
      <div class="toggle-row"><label>Grid</label><label class="toggle"><input type="checkbox" id="show-grid" checked><span class="slider"></span></label></div>
      <div class="toggle-row"><label>EE Trace</label><label class="toggle"><input type="checkbox" id="show-trace"><span class="slider"></span></label></div>
    </div>

    <div class="section">
      <h2>DH Parameters</h2>
      <table class="dh-table" id="dh-table">
        <thead><tr><th>Joint</th><th>&theta;</th><th>d</th><th>a</th><th>&alpha;</th></tr></thead>
        <tbody id="dh-body"></tbody>
      </table>
    </div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ================================================================
//  SECTION 1: MATH UTILITIES
// ================================================================

const DEG = 180 / Math.PI;
const RAD = Math.PI / 180;

function dhTransform(theta, d, a, alpha) {
  const ct = Math.cos(theta), st = Math.sin(theta);
  const ca = Math.cos(alpha), sa = Math.sin(alpha);
  return [
    ct, -st * ca,  st * sa, a * ct,
    st,  ct * ca, -ct * sa, a * st,
    0,   sa,       ca,      d,
    0,   0,        0,       1
  ];
}

function mat4Mul(A, B) {
  const R = new Array(16);
  for (let r = 0; r < 4; r++)
    for (let c = 0; c < 4; c++) {
      let s = 0;
      for (let k = 0; k < 4; k++) s += A[r * 4 + k] * B[k * 4 + c];
      R[r * 4 + c] = s;
    }
  return R;
}

function mat4Identity() {
  return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1];
}

function mat4Pos(M)  { return [M[3], M[7], M[11]]; }
function mat4AxisZ(M){ return [M[2], M[6], M[10]]; }

function v3Sub(a, b) { return [a[0]-b[0], a[1]-b[1], a[2]-b[2]]; }
function v3Add(a, b) { return [a[0]+b[0], a[1]+b[1], a[2]+b[2]]; }
function v3Scale(v, s){ return [v[0]*s, v[1]*s, v[2]*s]; }
function v3Cross(a, b){
  return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];
}
function v3Dot(a, b){ return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]; }
function v3Len(v){ return Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); }

function solveLinear(A, b, n) {
  const aug = [];
  for (let i = 0; i < n; i++) {
    aug[i] = new Float64Array(n + 1);
    for (let j = 0; j < n; j++) aug[i][j] = A[i * n + j];
    aug[i][n] = b[i];
  }
  for (let col = 0; col < n; col++) {
    let mx = col, mv = Math.abs(aug[col][col]);
    for (let r = col + 1; r < n; r++) {
      const v = Math.abs(aug[r][col]);
      if (v > mv) { mv = v; mx = r; }
    }
    [aug[col], aug[mx]] = [aug[mx], aug[col]];
    const p = aug[col][col];
    if (Math.abs(p) < 1e-12) continue;
    for (let r = col + 1; r < n; r++) {
      const f = aug[r][col] / p;
      for (let j = col; j <= n; j++) aug[r][j] -= f * aug[col][j];
    }
  }
  const x = new Float64Array(n);
  for (let i = n - 1; i >= 0; i--) {
    x[i] = aug[i][n];
    for (let j = i + 1; j < n; j++) x[i] -= aug[i][j] * x[j];
    if (Math.abs(aug[i][i]) > 1e-12) x[i] /= aug[i][i]; else x[i] = 0;
  }
  return x;
}

// ================================================================
//  SECTION 2: ROBOT KINEMATICS
// ================================================================

const PRESETS = {
  'kuka': {
    name: 'KUKA KR 500',
    dh: [ // [d, a, alpha]  theta is variable â€” Kuka KR 500 DH parameters
      [1.045, 0.500, -Math.PI/2],   // Joint 1: base rotation
      [0.000, 1.300,  0],           // Joint 2: shoulder (upper arm)
      [0.000, 0.055,  Math.PI/2],   // Joint 3: elbow
      [1.025, 0.000, -Math.PI/2],   // Joint 4: wrist rotation
      [0.000, 0.000,  Math.PI/2],   // Joint 5: wrist bend
      [0.290, 0.000,  0]            // Joint 6: tool flange
    ],
    limits: [[-185,185],[-130,20],[-100,144],[-350,350],[-130,130],[-350,350]]
  },
  'ur5': {
    name: 'UR5-like',
    dh: [
      [0.089, 0.00,   Math.PI/2],
      [0.00,  -0.425, 0],
      [0.00,  -0.392, 0],
      [0.109, 0.00,   Math.PI/2],
      [0.095, 0.00,  -Math.PI/2],
      [0.082, 0.00,   0]
    ],
    limits: [[-360,360],[-360,360],[-360,360],[-360,360],[-360,360],[-360,360]]
  },
  'scara': {
    name: '4-DOF SCARA',
    dh: [
      [0.35, 0.00,  0],
      [0.00, 0.70,  0],
      [0.00, 0.50,  Math.PI],
      [0.20, 0.00,  0]
    ],
    limits: [[-135,135],[-135,135],[-180,180],[-180,180]]
  },
  '3link': {
    name: '3-Link Planar',
    dh: [
      [0.00, 0.80, 0],
      [0.00, 0.60, 0],
      [0.00, 0.40, 0]
    ],
    limits: [[-180,180],[-150,150],[-150,150]]
  }
};

class Robot {
  constructor(presetKey) {
    const p = PRESETS[presetKey];
    this.name = p.name;
    this.dh = p.dh;
    this.nJoints = p.dh.length;
    this.limits = p.limits.map(l => [l[0] * RAD, l[1] * RAD]);
    this.angles = new Float64Array(this.nJoints);
  }

  clampAngles(angles) {
    const out = new Float64Array(angles.length);
    for (let i = 0; i < this.nJoints; i++) {
      out[i] = Math.max(this.limits[i][0], Math.min(this.limits[i][1], angles[i]));
    }
    return out;
  }

  fk(angles) {
    const transforms = [mat4Identity()];
    for (let i = 0; i < this.nJoints; i++) {
      const [d, a, alpha] = this.dh[i];
      const T = dhTransform(angles[i], d, a, alpha);
      transforms.push(mat4Mul(transforms[i], T));
    }
    return transforms;
  }

  jacobian(angles) {
    const T = this.fk(angles);
    const pe = mat4Pos(T[this.nJoints]);
    const n = this.nJoints;
    const Jp = new Float64Array(3 * n); // position rows
    const Jr = new Float64Array(3 * n); // orientation rows
    for (let i = 0; i < n; i++) {
      const z = mat4AxisZ(T[i]);
      const p = mat4Pos(T[i]);
      const d = v3Sub(pe, p);
      const cp = v3Cross(z, d);
      Jp[0 * n + i] = cp[0]; Jp[1 * n + i] = cp[1]; Jp[2 * n + i] = cp[2];
      Jr[0 * n + i] = z[0];  Jr[1 * n + i] = z[1];  Jr[2 * n + i] = z[2];
    }
    return { Jp, Jr, n };
  }

  solveIK(target, startAngles, opts = {}) {
    const maxIter = opts.maxIter || 200;
    const tol = opts.tol || 0.001;
    const lambda = opts.lambda || 0.5;
    const n = this.nJoints;
    let angles = new Float64Array(startAngles || this.angles);

    for (let iter = 0; iter < maxIter; iter++) {
      const T = this.fk(angles);
      const pe = mat4Pos(T[n]);
      const err = v3Sub(target, pe);
      const dist = v3Len(err);
      if (dist < tol) return { angles: this.clampAngles(angles), converged: true, error: dist, iterations: iter };

      const { Jp } = this.jacobian(angles);
      // Damped least squares: dq = J^T (J J^T + lambda^2 I)^-1 e
      // M = J J^T + lambda^2 I  (3x3)
      const M = new Float64Array(9);
      for (let r = 0; r < 3; r++)
        for (let c = 0; c < 3; c++) {
          let s = 0;
          for (let k = 0; k < n; k++) s += Jp[r * n + k] * Jp[c * n + k];
          M[r * 3 + c] = s + (r === c ? lambda * lambda : 0);
        }
      const v = solveLinear(M, [err[0], err[1], err[2]], 3);
      // dq = J^T v
      for (let i = 0; i < n; i++) {
        let dq = 0;
        for (let r = 0; r < 3; r++) dq += Jp[r * n + i] * v[r];
        angles[i] += dq;
      }
      angles = this.clampAngles(angles);
    }
    const T = this.fk(angles);
    const pe = mat4Pos(T[n]);
    return { angles, converged: false, error: v3Len(v3Sub(target, pe)), iterations: maxIter };
  }
}

// ================================================================
//  SECTION 3: 3D VISUALIZATION
// ================================================================

const JOINT_COLORS = [0xef4444, 0xf97316, 0xeab308, 0x22c55e, 0x3b82f6, 0xa855f7, 0xec4899, 0x14b8a6];
const LINK_COLOR = 0x52525b;

class Visualizer {
  constructor(canvas) {
    this.canvas = canvas;
    this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
    this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.renderer.setClearColor(0x09090b);
    this.renderer.shadowMap.enabled = true;

    this.scene = new THREE.Scene();
    this.camera = new THREE.PerspectiveCamera(50, 1, 0.01, 100);
    this.camera.position.set(2.5, 2.0, 2.5);
    this.camera.lookAt(0, 0.6, 0);

    this.robotGroup = new THREE.Group();
    this.scene.add(this.robotGroup);
    this.jointMeshes = [];
    this.linkMeshes = [];
    this.frameMeshes = [];
    this.tracePoints = [];
    this.traceLine = null;

    this._setupLights();
    this._createGrid();
    this._createWorldAxes();
    this._createTarget();
    this._createWaypointGroup();
    this._initOrbitControls();
    this._initDrag();

    this.showFrames = false;
    this.showGrid = true;
    this.showTrace = false;
  }

  _setupLights() {
    this.scene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(5, 8, 5);
    dir.castShadow = true;
    this.scene.add(dir);
    const fill = new THREE.DirectionalLight(0x8888ff, 0.3);
    fill.position.set(-3, 4, -3);
    this.scene.add(fill);
  }

  _createGrid() {
    this.grid = new THREE.GridHelper(6, 30, 0x3f3f46, 0x3f3f46);
    this.scene.add(this.grid);
  }

  _createWorldAxes() {
    const axes = new THREE.AxesHelper(0.5);
    this.scene.add(axes);
  }

  _createTarget() {
    const geo = new THREE.SphereGeometry(0.06, 24, 24);
    const mat = new THREE.MeshStandardMaterial({ color: 0xf59e0b, emissive: 0xf59e0b, emissiveIntensity: 0.4, transparent: true, opacity: 0.9 });
    this.targetMesh = new THREE.Mesh(geo, mat);
    this.targetMesh.visible = false;
    this.scene.add(this.targetMesh);

    const ringGeo = new THREE.RingGeometry(0.08, 0.1, 32);
    const ringMat = new THREE.MeshBasicMaterial({ color: 0xf59e0b, side: THREE.DoubleSide, transparent: true, opacity: 0.5 });
    this.targetRingX = new THREE.Mesh(ringGeo, ringMat);
    this.targetRingX.rotation.y = Math.PI / 2;
    this.targetMesh.add(this.targetRingX);
    this.targetRingY = new THREE.Mesh(ringGeo.clone(), ringMat.clone());
    this.targetRingY.rotation.x = Math.PI / 2;
    this.targetMesh.add(this.targetRingY);
    this.targetRingZ = new THREE.Mesh(ringGeo.clone(), ringMat.clone());
    this.targetMesh.add(this.targetRingZ);
  }

  setTarget(pos, visible) {
    this.targetMesh.position.set(pos[0], pos[1], pos[2]);
    this.targetMesh.visible = visible;
  }

  buildRobot(nJoints) {
    // Clear old
    while (this.robotGroup.children.length) this.robotGroup.remove(this.robotGroup.children[0]);
    this.jointMeshes = [];
    this.linkMeshes = [];
    this.frameMeshes = [];

    // Base
    const baseMat = new THREE.MeshStandardMaterial({ color: 0x3f3f46, metalness: 0.6, roughness: 0.3 });
    const base = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.15, 0.06, 32), baseMat);
    base.position.y = 0.03;
    this.robotGroup.add(base);

    for (let i = 0; i <= nJoints; i++) {
      // Joint sphere
      const jc = JOINT_COLORS[i % JOINT_COLORS.length];
      const jMat = new THREE.MeshStandardMaterial({ color: jc, emissive: jc, emissiveIntensity: 0.2, metalness: 0.3, roughness: 0.4 });
      const radius = 0.055 - i * 0.003;
      const jMesh = new THREE.Mesh(new THREE.SphereGeometry(Math.max(radius, 0.025), 20, 20), jMat);
      this.robotGroup.add(jMesh);
      this.jointMeshes.push(jMesh);

      // Link cylinder (between joint i and i+1)
      if (i < nJoints) {
        const lMat = new THREE.MeshStandardMaterial({ color: LINK_COLOR, metalness: 0.5, roughness: 0.35 });
        const lMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, 1, 12), lMat);
        this.robotGroup.add(lMesh);
        this.linkMeshes.push(lMesh);
      }

      // Coordinate frame axes
      const frameGroup = new THREE.Group();
      const axLen = 0.12;
      const makeLine = (dir, color) => {
        const geo = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(0,0,0),
          new THREE.Vector3(dir[0]*axLen, dir[1]*axLen, dir[2]*axLen)
        ]);
        return new THREE.Line(geo, new THREE.LineBasicMaterial({ color }));
      };
      frameGroup.add(makeLine([1,0,0], 0xff3333));
      frameGroup.add(makeLine([0,1,0], 0x33ff33));
      frameGroup.add(makeLine([0,0,1], 0x3333ff));
      frameGroup.visible = false;
      this.robotGroup.add(frameGroup);
      this.frameMeshes.push(frameGroup);
    }

    // Trace line
    if (this.traceLine) this.scene.remove(this.traceLine);
    this.tracePoints = [];
    const traceGeo = new THREE.BufferGeometry();
    traceGeo.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
    this.traceLine = new THREE.Line(traceGeo, new THREE.LineBasicMaterial({ color: 0xf59e0b, transparent: true, opacity: 0.5 }));
    this.scene.add(this.traceLine);
  }

  updateRobot(transforms) {
    const n = transforms.length - 1; // nJoints
    for (let i = 0; i <= n; i++) {
      const pos = mat4Pos(transforms[i]);
      this.jointMeshes[i].position.set(pos[0], pos[1], pos[2]);

      // Frame
      if (this.frameMeshes[i]) {
        this.frameMeshes[i].position.set(pos[0], pos[1], pos[2]);
        const m = transforms[i];
        const mat = new THREE.Matrix4();
        mat.set(
          m[0], m[1], m[2], 0,
          m[4], m[5], m[6], 0,
          m[8], m[9], m[10], 0,
          0, 0, 0, 1
        );
        this.frameMeshes[i].setRotationFromMatrix(mat);
        this.frameMeshes[i].visible = this.showFrames;
      }
    }

    // Links
    for (let i = 0; i < n; i++) {
      const pA = mat4Pos(transforms[i]);
      const pB = mat4Pos(transforms[i + 1]);
      const mid = [(pA[0]+pB[0])/2, (pA[1]+pB[1])/2, (pA[2]+pB[2])/2];
      const dir = v3Sub(pB, pA);
      const len = v3Len(dir);
      if (len < 0.001) {
        this.linkMeshes[i].visible = false;
        continue;
      }
      this.linkMeshes[i].visible = true;
      this.linkMeshes[i].position.set(mid[0], mid[1], mid[2]);
      this.linkMeshes[i].scale.set(1, len, 1);
      const up = new THREE.Vector3(0, 1, 0);
      const d = new THREE.Vector3(dir[0]/len, dir[1]/len, dir[2]/len);
      const q = new THREE.Quaternion().setFromUnitVectors(up, d);
      this.linkMeshes[i].quaternion.copy(q);
    }

    // EE trace
    if (this.showTrace) {
      const ee = mat4Pos(transforms[n]);
      this.tracePoints.push(ee[0], ee[1], ee[2]);
      if (this.tracePoints.length > 30000) this.tracePoints.splice(0, 3);
      this.traceLine.geometry.setAttribute('position', new THREE.Float32BufferAttribute(this.tracePoints, 3));
      this.traceLine.geometry.attributes.position.needsUpdate = true;
      this.traceLine.visible = true;
    } else {
      this.traceLine.visible = false;
    }

    this.grid.visible = this.showGrid;
  }

  clearTrace() {
    this.tracePoints = [];
    this.traceLine.geometry.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
  }

  // ---- Waypoint Visualization ----
  _createWaypointGroup() {
    this.waypointGroup = new THREE.Group();
    this.scene.add(this.waypointGroup);
    this.waypointMeshes = [];
    this.waypointPathLine = null;
  }

  setWaypoints(points) {
    while (this.waypointGroup.children.length) this.waypointGroup.remove(this.waypointGroup.children[0]);
    this.waypointMeshes = [];
    if (this.waypointPathLine) { this.scene.remove(this.waypointPathLine); this.waypointPathLine = null; }
    if (!points || points.length === 0) return;

    const wpGeo = new THREE.SphereGeometry(0.035, 16, 16);
    for (let i = 0; i < points.length; i++) {
      const p = points[i];
      const mat = new THREE.MeshStandardMaterial({ color: 0xf59e0b, emissive: 0xf59e0b, emissiveIntensity: 0.3, transparent: true, opacity: 0.7 });
      const mesh = new THREE.Mesh(wpGeo, mat);
      mesh.position.set(p[0], p[1], p[2]);
      this.waypointGroup.add(mesh);
      this.waypointMeshes.push(mesh);
    }

    const linePoints = points.map(p => new THREE.Vector3(p[0], p[1], p[2]));
    const lineGeo = new THREE.BufferGeometry().setFromPoints(linePoints);
    this.waypointPathLine = new THREE.Line(lineGeo, new THREE.LineDashedMaterial({ color: 0xf59e0b, transparent: true, opacity: 0.35, dashSize: 0.05, gapSize: 0.03 }));
    this.waypointPathLine.computeLineDistances();
    this.scene.add(this.waypointPathLine);
  }

  highlightWaypoint(index) {
    for (let i = 0; i < this.waypointMeshes.length; i++) {
      const m = this.waypointMeshes[i];
      if (i === index) {
        m.material.opacity = 1.0;
        m.material.emissiveIntensity = 0.6;
        m.scale.setScalar(1.6);
      } else if (i < index) {
        m.material.opacity = 0.3;
        m.material.emissiveIntensity = 0.1;
        m.scale.setScalar(1);
      } else {
        m.material.opacity = 0.7;
        m.material.emissiveIntensity = 0.3;
        m.scale.setScalar(1);
      }
    }
  }

  clearWaypoints() {
    while (this.waypointGroup.children.length) this.waypointGroup.remove(this.waypointGroup.children[0]);
    this.waypointMeshes = [];
    if (this.waypointPathLine) { this.scene.remove(this.waypointPathLine); this.waypointPathLine = null; }
  }

  // ---- Orbit Camera Controls ----
  _initOrbitControls() {
    this._orbitState = { rotating: false, panning: false, sx: 0, sy: 0 };
    this._spherical = { radius: 4.2, theta: Math.PI / 4, phi: Math.PI / 3 };
    this._target = new THREE.Vector3(0, 0.5, 0);

    const el = this.canvas;
    el.addEventListener('pointerdown', e => {
      if (this._draggingTarget) return;
      if (e.button === 0) this._orbitState.rotating = true;
      if (e.button === 2) this._orbitState.panning = true;
      this._orbitState.sx = e.clientX;
      this._orbitState.sy = e.clientY;
      el.setPointerCapture(e.pointerId);
    });
    el.addEventListener('pointermove', e => {
      const dx = e.clientX - this._orbitState.sx;
      const dy = e.clientY - this._orbitState.sy;
      this._orbitState.sx = e.clientX;
      this._orbitState.sy = e.clientY;
      if (this._orbitState.rotating) {
        this._spherical.theta -= dx * 0.008;
        this._spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this._spherical.phi - dy * 0.008));
      }
      if (this._orbitState.panning) {
        const right = new THREE.Vector3().setFromMatrixColumn(this.camera.matrixWorld, 0);
        const up = new THREE.Vector3().setFromMatrixColumn(this.camera.matrixWorld, 1);
        const panSpeed = 0.003 * this._spherical.radius;
        this._target.add(right.multiplyScalar(-dx * panSpeed));
        this._target.add(up.multiplyScalar(dy * panSpeed));
      }
    });
    el.addEventListener('pointerup', () => {
      this._orbitState.rotating = false;
      this._orbitState.panning = false;
    });
    el.addEventListener('wheel', e => {
      e.preventDefault();
      this._spherical.radius *= 1 + e.deltaY * 0.001;
      this._spherical.radius = Math.max(0.5, Math.min(20, this._spherical.radius));
    }, { passive: false });
    el.addEventListener('contextmenu', e => e.preventDefault());
  }

  _updateCamera() {
    const { radius, theta, phi } = this._spherical;
    this.camera.position.set(
      this._target.x + radius * Math.sin(phi) * Math.cos(theta),
      this._target.y + radius * Math.cos(phi),
      this._target.z + radius * Math.sin(phi) * Math.sin(theta)
    );
    this.camera.lookAt(this._target);
  }

  // ---- Target Dragging ----
  _initDrag() {
    this._draggingTarget = false;
    this._raycaster = new THREE.Raycaster();
    this._dragPlane = new THREE.Plane();
    this._mouse = new THREE.Vector2();

    const el = this.canvas;
    el.addEventListener('pointerdown', e => {
      if (e.button !== 0 || !this.targetMesh.visible) return;
      this._updateMouse(e);
      this._raycaster.setFromCamera(this._mouse, this.camera);
      const hits = this._raycaster.intersectObject(this.targetMesh);
      if (hits.length > 0) {
        this._draggingTarget = true;
        this._orbitState.rotating = false;
        const camDir = new THREE.Vector3();
        this.camera.getWorldDirection(camDir);
        this._dragPlane.setFromNormalAndCoplanarPoint(camDir.negate(), this.targetMesh.position);
        el.setPointerCapture(e.pointerId);
      }
    });
    el.addEventListener('pointermove', e => {
      if (!this._draggingTarget) return;
      this._updateMouse(e);
      this._raycaster.setFromCamera(this._mouse, this.camera);
      const pt = new THREE.Vector3();
      if (this._raycaster.ray.intersectPlane(this._dragPlane, pt)) {
        this.targetMesh.position.copy(pt);
        if (this.onTargetDrag) this.onTargetDrag([pt.x, pt.y, pt.z]);
      }
    });
    el.addEventListener('pointerup', () => {
      if (this._draggingTarget) {
        this._draggingTarget = false;
        const p = this.targetMesh.position;
        if (this.onTargetDrop) this.onTargetDrop([p.x, p.y, p.z]);
      }
    });
  }

  _updateMouse(e) {
    const rect = this.canvas.getBoundingClientRect();
    this._mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
    this._mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
  }

  resize() {
    const w = this.canvas.parentElement.clientWidth;
    const h = this.canvas.parentElement.clientHeight;
    this.renderer.setSize(w, h, false);
    this.camera.aspect = w / h;
    this.camera.updateProjectionMatrix();
  }

  render() {
    this._updateCamera();
    this.renderer.render(this.scene, this.camera);
  }
}

// ================================================================
//  SECTION 4: APP CONTROLLER
// ================================================================

class App {
  constructor() {
    this.canvas = document.getElementById('viewport');
    this.vis = new Visualizer(this.canvas);
    this.mode = 'fk'; // 'fk' or 'ik'
    this.presetKey = 'kuka';
    this.robot = new Robot(this.presetKey);
    this._animating = false;
    this._animTarget = null;
    this._animStart = null;
    this._animDuration = 0;
    this._animStartTime = 0;

    // Path planner state
    this._pathWaypoints = [];
    this._pathPlaying = false;
    this._pathCurrentIdx = 0;
    this._pathInited = false;
  }

  init() {
    this.vis.buildRobot(this.robot.nJoints);
    this._buildSliders();
    this._updateDHTable();
    this._updateFK();
    this._bindEvents();
    this.vis.resize();
    this._loop();
  }

  _buildSliders() {
    const container = document.getElementById('fk-sliders');
    container.innerHTML = '';
    const colors = ['var(--j0)','var(--j1)','var(--j2)','var(--j3)','var(--j4)','var(--j5)'];
    for (let i = 0; i < this.robot.nJoints; i++) {
      const lim = this.robot.limits[i];
      const minD = Math.round(lim[0] * DEG);
      const maxD = Math.round(lim[1] * DEG);
      const c = colors[i % colors.length];
      const div = document.createElement('div');
      div.className = 'joint-row';
      div.innerHTML = `
        <div class="joint-header">
          <span class="joint-label" style="color:${c}">J${i+1}</span>
          <span class="joint-value" id="jv-${i}">0.0&deg;</span>
        </div>
        <input type="range" id="js-${i}" min="${minD}" max="${maxD}" value="0" step="0.5"
          style="--c:${c}">`;
      container.appendChild(div);
      const slider = div.querySelector('input');
      // Color the thumb
      slider.style.setProperty('accent-color', c);
      slider.addEventListener('input', () => {
        this.robot.angles[i] = parseFloat(slider.value) * RAD;
        document.getElementById(`jv-${i}`).textContent = slider.value + '\u00B0';
        this._updateFK();
      });
    }
  }

  _updateDHTable() {
    const tbody = document.getElementById('dh-body');
    tbody.innerHTML = '';
    for (let i = 0; i < this.robot.nJoints; i++) {
      const [d, a, alpha] = this.robot.dh[i];
      const tr = document.createElement('tr');
      tr.innerHTML = `<td style="color:${['var(--j0)','var(--j1)','var(--j2)','var(--j3)','var(--j4)','var(--j5)'][i % 6]}">J${i+1}</td>
        <td id="dh-theta-${i}">${(this.robot.angles[i] * DEG).toFixed(1)}&deg;</td>
        <td>${d.toFixed(3)}</td><td>${a.toFixed(3)}</td><td>${(alpha * DEG).toFixed(1)}&deg;</td>`;
      tbody.appendChild(tr);
    }
  }

  _updateFK() {
    const T = this.robot.fk(this.robot.angles);
    this.vis.updateRobot(T);

    const ee = mat4Pos(T[this.robot.nJoints]);
    document.getElementById('ee-x').textContent = ee[0].toFixed(3);
    document.getElementById('ee-y').textContent = ee[1].toFixed(3);
    document.getElementById('ee-z').textContent = ee[2].toFixed(3);
    document.getElementById('ee-r').textContent = v3Len(ee).toFixed(3);

    // Update DH theta column
    for (let i = 0; i < this.robot.nJoints; i++) {
      const el = document.getElementById(`dh-theta-${i}`);
      if (el) el.textContent = (this.robot.angles[i] * DEG).toFixed(1) + '\u00B0';
    }
  }

  _setMode(mode) {
    // Stop path playback if leaving path mode
    if (this.mode === 'path' && mode !== 'path') {
      this._stopPath();
      this.vis.clearWaypoints();
    }
    this.mode = mode;
    document.querySelectorAll('.mode-btn').forEach(b => b.classList.toggle('active', b.dataset.mode === mode));
    document.getElementById('fk-section').style.display = mode === 'fk' ? '' : 'none';
    document.getElementById('ik-section').style.display = mode === 'ik' ? '' : 'none';
    document.getElementById('path-section').style.display = mode === 'path' ? '' : 'none';

    if (mode === 'ik') {
      const T = this.robot.fk(this.robot.angles);
      const ee = mat4Pos(T[this.robot.nJoints]);
      document.getElementById('ik-x').value = ee[0].toFixed(3);
      document.getElementById('ik-y').value = ee[1].toFixed(3);
      document.getElementById('ik-z').value = ee[2].toFixed(3);
      this.vis.setTarget(ee, true);
    } else if (mode === 'path') {
      this._initPathWaypoints();
      this._updateWaypointVis();
      this.vis.setTarget([0,0,0], false);
    } else {
      this.vis.setTarget([0,0,0], false);
      document.getElementById('ik-status').style.display = 'none';
    }
  }

  _runIK(target) {
    const statusEl = document.getElementById('ik-status');
    statusEl.style.display = '';
    statusEl.className = 'ik-status working';
    statusEl.textContent = 'Solving...';

    const result = this.robot.solveIK(target, this.robot.angles, { maxIter: 300, tol: 0.001, lambda: 0.4 });

    if (result.converged || result.error < 0.01) {
      statusEl.className = 'ik-status ok';
      statusEl.textContent = `Converged in ${result.iterations} iter (err: ${result.error.toFixed(4)})`;
      this._animateToAngles(result.angles, 400);
    } else {
      statusEl.className = 'ik-status fail';
      statusEl.textContent = `No solution (err: ${result.error.toFixed(3)}). Target may be out of reach.`;
      // Still apply best attempt
      this._animateToAngles(result.angles, 400);
    }
  }

  _animateToAngles(targetAngles, durationMs) {
    this._animStart = new Float64Array(this.robot.angles);
    this._animTarget = new Float64Array(targetAngles);
    this._animDuration = durationMs;
    this._animStartTime = performance.now();
    this._animating = true;
  }

  _tickAnimation(now) {
    if (!this._animating) return;
    let t = (now - this._animStartTime) / this._animDuration;
    let done = false;
    if (t >= 1) { t = 1; this._animating = false; done = true; }
    // Smooth ease
    t = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    for (let i = 0; i < this.robot.nJoints; i++) {
      this.robot.angles[i] = this._animStart[i] + (this._animTarget[i] - this._animStart[i]) * t;
    }
    this._syncSliders();
    this._updateFK();

    // Path playback: advance to next waypoint when segment finishes
    if (done && this._pathPlaying) {
      this._pathCurrentIdx++;
      setTimeout(() => this._advancePath(), 120);
    }
  }

  _syncSliders() {
    for (let i = 0; i < this.robot.nJoints; i++) {
      const s = document.getElementById(`js-${i}`);
      const v = document.getElementById(`jv-${i}`);
      if (s) {
        const deg = (this.robot.angles[i] * DEG).toFixed(1);
        s.value = deg;
        v.textContent = deg + '\u00B0';
      }
    }
  }

  // ---- Path Planner ----
  _initPathWaypoints() {
    if (this._pathInited) {
      this._updateWaypointVis();
      return;
    }
    this._pathInited = true;

    // Generate a default circular path within robot workspace
    const T = this.robot.fk(this.robot.angles);
    const ee = mat4Pos(T[this.robot.nJoints]);
    const cx = 0, cz = 0;
    const cy = ee[1] * 0.5;
    const r = Math.max(0.15, v3Len(ee) * 0.2);

    this._pathWaypoints = [];
    for (let i = 0; i < 10; i++) {
      const angle = (i / 10) * Math.PI * 2;
      this._pathWaypoints.push([
        cx + r * Math.cos(angle),
        cy + 0.3,
        cz + r * Math.sin(angle)
      ]);
    }
    this._buildWaypointUI();
  }

  _resetPathForPreset() {
    this._pathInited = false;
    this._pathPlaying = false;
    this._pathCurrentIdx = 0;
    this.vis.clearWaypoints();
    if (this.mode === 'path') {
      this._initPathWaypoints();
      this._updateWaypointVis();
    }
  }

  _buildWaypointUI() {
    const container = document.getElementById('wp-list');
    container.innerHTML = '';
    for (let i = 0; i < 10; i++) {
      const wp = this._pathWaypoints[i];
      const div = document.createElement('div');
      div.className = 'wp-row';
      div.id = `wp-row-${i}`;
      div.innerHTML = `
        <span class="wp-num">${i + 1}</span>
        <input type="number" step="0.05" value="${wp[0].toFixed(2)}" data-wp="${i}" data-axis="0">
        <input type="number" step="0.05" value="${wp[1].toFixed(2)}" data-wp="${i}" data-axis="1">
        <input type="number" step="0.05" value="${wp[2].toFixed(2)}" data-wp="${i}" data-axis="2">`;
      container.appendChild(div);
      div.querySelectorAll('input').forEach(inp => {
        inp.addEventListener('input', () => {
          const wpIdx = parseInt(inp.dataset.wp);
          const axis = parseInt(inp.dataset.axis);
          this._pathWaypoints[wpIdx][axis] = parseFloat(inp.value) || 0;
          this._updateWaypointVis();
        });
      });
    }
  }

  _updateWaypointVis() {
    this.vis.setWaypoints(this._pathWaypoints);
  }

  _playPath() {
    if (this._pathPlaying) return;
    this._pathPlaying = true;
    this._pathCurrentIdx = 0;

    // Enable trace to visualize robot motion
    this.vis.showTrace = true;
    this.vis.clearTrace();
    document.getElementById('show-trace').checked = true;

    document.getElementById('path-play').textContent = 'Playing...';
    document.getElementById('path-play').disabled = true;

    this._advancePath();
  }

  _advancePath() {
    if (!this._pathPlaying) return;

    if (this._pathCurrentIdx >= 10) {
      this._stopPath();
      document.getElementById('path-progress').textContent = 'Path complete!';
      return;
    }

    const idx = this._pathCurrentIdx;
    const target = this._pathWaypoints[idx];

    // Update progress text
    document.getElementById('path-progress').textContent = `Waypoint ${idx + 1} / 10`;

    // Highlight in 3D
    this.vis.highlightWaypoint(idx);
    this.vis.setTarget(target, true);

    // Highlight in UI
    document.querySelectorAll('.wp-row').forEach((r, i) => {
      r.classList.toggle('active', i === idx);
      r.classList.toggle('reached', i < idx);
    });

    // Solve IK
    const result = this.robot.solveIK(target, this.robot.angles, { maxIter: 300, tol: 0.001, lambda: 0.4 });

    // Get speed from dropdown
    const speed = parseInt(document.getElementById('path-speed').value) || 800;

    // Animate to solution
    this._animateToAngles(result.angles, speed);
  }

  _stopPath() {
    const wasPlaying = this._pathPlaying;
    this._pathPlaying = false;
    this._animating = false;

    document.getElementById('path-play').textContent = 'Play';
    document.getElementById('path-play').disabled = false;

    if (!wasPlaying) {
      document.getElementById('path-progress').textContent = '';
    } else if (this._pathCurrentIdx < 10) {
      document.getElementById('path-progress').textContent = 'Stopped';
    }

    // Reset UI highlights
    document.querySelectorAll('.wp-row').forEach(r => {
      r.classList.remove('active');
    });

    this.vis.setTarget([0, 0, 0], false);
    // Reset waypoint highlight
    for (let i = 0; i < this.vis.waypointMeshes.length; i++) {
      const m = this.vis.waypointMeshes[i];
      m.material.opacity = 0.7;
      m.material.emissiveIntensity = 0.3;
      m.scale.setScalar(1);
    }
  }

  _bindEvents() {
    // Mode toggle
    document.querySelectorAll('.mode-btn').forEach(b => {
      b.addEventListener('click', () => this._setMode(b.dataset.mode));
    });

    // Preset
    document.getElementById('preset-select').addEventListener('change', e => {
      this.presetKey = e.target.value;
      this.robot = new Robot(this.presetKey);
      this.vis.buildRobot(this.robot.nJoints);
      this.vis.clearTrace();
      this._buildSliders();
      this._updateDHTable();
      this._updateFK();
      this._resetPathForPreset();
      if (this.mode === 'ik') {
        const T = this.robot.fk(this.robot.angles);
        const ee = mat4Pos(T[this.robot.nJoints]);
        this.vis.setTarget(ee, true);
      }
    });

    // Reset
    document.getElementById('reset-joints').addEventListener('click', () => {
      this.robot.angles.fill(0);
      this._syncSliders();
      this._updateFK();
      this.vis.clearTrace();
    });

    // IK solve button
    document.getElementById('solve-ik').addEventListener('click', () => {
      const x = parseFloat(document.getElementById('ik-x').value) || 0;
      const y = parseFloat(document.getElementById('ik-y').value) || 0;
      const z = parseFloat(document.getElementById('ik-z').value) || 0;
      this.vis.setTarget([x, y, z], true);
      this._runIK([x, y, z]);
    });

    // Target drag
    this.vis.onTargetDrag = pos => {
      document.getElementById('ik-x').value = pos[0].toFixed(3);
      document.getElementById('ik-y').value = pos[1].toFixed(3);
      document.getElementById('ik-z').value = pos[2].toFixed(3);
      // Live IK while dragging
      const result = this.robot.solveIK(pos, this.robot.angles, { maxIter: 50, tol: 0.005, lambda: 0.6 });
      this.robot.angles = result.angles;
      this._syncSliders();
      this._updateFK();
    };
    this.vis.onTargetDrop = pos => {
      this._runIK(pos);
    };

    // Path planner
    document.getElementById('path-play').addEventListener('click', () => this._playPath());
    document.getElementById('path-stop').addEventListener('click', () => this._stopPath());

    // Display toggles
    document.getElementById('show-frames').addEventListener('change', e => {
      this.vis.showFrames = e.target.checked;
      this._updateFK();
    });
    document.getElementById('show-grid').addEventListener('change', e => {
      this.vis.showGrid = e.target.checked;
      this._updateFK();
    });
    document.getElementById('show-trace').addEventListener('change', e => {
      this.vis.showTrace = e.target.checked;
      if (!e.target.checked) this.vis.clearTrace();
      this._updateFK();
    });

    // Resize
    window.addEventListener('resize', () => this.vis.resize());
  }

  _loop() {
    const tick = (now) => {
      this._tickAnimation(now);
      this.vis.render();
      requestAnimationFrame(tick);
    };
    requestAnimationFrame(tick);
  }
}

// ================================================================
//  BOOT
// ================================================================

const app = new App();
app.init();

if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('sw.js').catch(() => {});
}
</script>
</body>
</html>
